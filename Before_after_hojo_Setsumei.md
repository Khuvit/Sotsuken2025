# シミュレーション出力

このファイルは `reg_before.mem`, `reg_after.mem`, `data_before.mem`, `data_after.mem` の内容の説明です。
ここの内容では自分の向けの説明分が多くあるので少し長くなっています。ご了承ください。

1) 共通ルール
- コメント行: `// 0x00000000` のようにアドレス区切りが入ります。
- `x` は未初期化（不定値）を示します。

2) `reg_before.mem` / `reg_after.mem`（レジスタダンプ）
- 目的: テスト実行の前後でのレジスタファイル（x0..x31）の状態を保存します。
- フォーマット: 32 行分のビット列（1 行 = 32 ビット）を 2 ブロック（各 16 行）で表示します。
- 行の対応: ファイル先頭から順に x0, x1, ..., x15、次のブロックが x16, ..., x31 になります。
- ビット順: 1 行は左→右が MSB→LSB（例: "11011110..."）。
- 例: `11011110101011011011111011101111` を 8 ビットごとに分けると `11011110 10101101 10111110 11101111` → 16 進で `DE AD BE EF` → 0xDEADBEEF。

3) `data_before.mem` / `data_after.mem`（データメモリダンプ）
- 目的: データメモリのバイト単位の中身をテスト前後で確認するためのダンプです。
- フォーマット: 1 行 = 1 バイト を 8 ビットで表示（例: `11101111`）。コメント行でアドレスが示されます。
- バイト順: ファイルはアドレス増加順（0x00, 0x01, ...）で並びます。メモリはリトルエンディアン（低位バイトが先）で扱われています。
- 例: 先頭 4 行が
  - `11101111` (addr 0x00)
  - `10111110` (addr 0x01)
  - `10101101` (addr 0x02)
  - `11011110` (addr 0x03)
 なら、バイト列は 0xEF,0xBE,0xAD,0xDE で、32-bit ワードは 0xDEADBEEF になります。

4) 使い方のヒント（簡単）
- レジスタ x1 が期待値（例: 0xDEADBEEF）になっているかを確認するには `reg_after.mem` の 2 行目を 2 進→16 進に変換します（サンプルは上記）。
- データメモリの特定アドレスのワード値を確認するには 4 バイトずつ読み、リトルエンディアン順で結合してください。